#!/usr/bin/env bash
# speckit/scripts/evaluate-session.sh - Evaluate session patterns for learning
# Runs on Stop/SessionEnd hook to extract reusable patterns from Claude Code sessions
# Uses JSON output to optionally block Claude and request session documentation
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/common.sh"

# =============================================================================
# Configuration
# =============================================================================

# Minimum session length to trigger evaluation
MIN_SESSION_LENGTH=3

# Read JSON input from stdin (Claude Code passes hook data via stdin)
INPUT_JSON=$(cat 2>/dev/null || echo "{}")

# =============================================================================
# Path Configuration
# =============================================================================

# Get project root - prefer CLAUDE_PROJECT_DIR env var, fallback to search
get_project_root() {
    # Use Claude Code's project dir if available
    if [[ -n "${CLAUDE_PROJECT_DIR:-}" && -d "$CLAUDE_PROJECT_DIR/.specify" ]]; then
        echo "$CLAUDE_PROJECT_DIR"
        return 0
    fi
    # Fallback: search up from current directory
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/.specify" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    # Final fallback: use git root
    get_repo_root
}

PROJECT_ROOT=$(get_project_root)
SESSIONS_DIR="$PROJECT_ROOT/.specify/sessions"
LEARNING_DIR="$PROJECT_ROOT/.specify/learning"
SKILLS_DIR="$PROJECT_ROOT/.specify/skills/learned"

# =============================================================================
# Helper Functions
# =============================================================================

# Extract fields from JSON input
get_json_field() {
    local field="$1"
    echo "$INPUT_JSON" | grep -o "\"$field\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | sed 's/.*"\([^"]*\)"$/\1/' || echo ""
}

get_json_bool() {
    local field="$1"
    echo "$INPUT_JSON" | grep -o "\"$field\"[[:space:]]*:[[:space:]]*[a-z]*" | sed 's/.*:[[:space:]]*//' || echo "false"
}

# Log status message
log_status() {
    echo "[SpecKit:EvaluateSession] $1" >&2
}

# =============================================================================
# Session Analysis
# =============================================================================

# Count user messages in transcript
count_user_messages() {
    local transcript_path="$1"

    if [[ -f "$transcript_path" ]]; then
        grep -c '"type":"user"' "$transcript_path" 2>/dev/null || echo "0"
    else
        echo "0"
    fi
}

# Extract session patterns from corrections file
analyze_corrections() {
    local session_dir="$1"
    local corrections_file="$session_dir/corrections.jsonl"

    if [[ ! -f "$corrections_file" ]]; then
        echo "0"
        return
    fi

    wc -l < "$corrections_file" | tr -d ' '
}

# Queue session for background analysis
queue_for_analysis() {
    local session_dir="$1"
    local session_id="$2"

    local pending_dir="$LEARNING_DIR/pending-analysis"
    mkdir -p "$pending_dir"

    # Create queue file
    echo "$session_dir" > "$pending_dir/${session_id}.pending"

    log_status "Session queued for analysis: $session_id"
}

# Create session summary file
create_session_summary() {
    local session_id="$1"
    local message_count="$2"
    local correction_count="$3"

    local today=$(date +%Y-%m-%d)
    local short_id="${session_id: -8}"
    local session_file="$SESSIONS_DIR/${today}-${short_id}-session.md"

    mkdir -p "$SESSIONS_DIR"

    # Only create if doesn't exist
    if [[ ! -f "$session_file" ]]; then
        cat > "$session_file" << EOF
# Session: ${today} (${short_id})

## Summary

**Started:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
**Messages:** ${message_count}
**Corrections:** ${correction_count}

## Current State

_Document the current state of work at session end._

## Completed

- [ ] _List completed tasks_

## In Progress

- [ ] _List in-progress tasks_

## Notes for Next Session

_Add any notes that should be carried forward._

---
*Auto-generated by SpecKit*
EOF
    fi

    echo "$session_file"
}

# =============================================================================
# Feature State Capture
# =============================================================================

# Capture current feature state for session context
capture_feature_state() {
    local feature_dir
    feature_dir=$(get_feature_dir 2>/dev/null) || feature_dir=""

    if [[ -z "$feature_dir" || ! -d "$feature_dir" ]]; then
        return
    fi

    local tasks_file="${feature_dir}/tasks.md"
    if [[ -f "$tasks_file" ]]; then
        local pending=$(grep -c '\[ \]' "$tasks_file" 2>/dev/null || echo "0")
        local completed=$(grep -c '\[[xX]\]' "$tasks_file" 2>/dev/null || echo "0")
        log_status "Feature tasks: $completed completed, $pending pending"
    fi
}

# =============================================================================
# Main
# =============================================================================

main() {
    # Ensure directories exist
    mkdir -p "$SKILLS_DIR"
    mkdir -p "$SESSIONS_DIR"
    mkdir -p "$LEARNING_DIR/pending-analysis"

    # Check if stop hook is already active (prevent infinite loop)
    local stop_hook_active
    stop_hook_active=$(get_json_bool "stop_hook_active")
    if [[ "$stop_hook_active" == "true" ]]; then
        # Already ran once, allow stop
        exit 0
    fi

    # Get session ID
    local session_id
    session_id=$(get_json_field "session_id")

    if [[ -z "$session_id" ]]; then
        # Try to read from learning state
        if [[ -f "$LEARNING_DIR/.current-session-id" ]]; then
            session_id=$(cat "$LEARNING_DIR/.current-session-id")
        else
            # Generate fallback ID
            session_id="session-$(date +%Y%m%d%H%M%S)"
        fi
    fi

    log_status "Evaluating session: $session_id"

    # Get transcript path from JSON input
    local transcript_path
    transcript_path=$(get_json_field "transcript_path")

    local message_count=0
    if [[ -n "$transcript_path" && -f "$transcript_path" ]]; then
        message_count=$(count_user_messages "$transcript_path")
    fi

    # Skip very short sessions
    if [[ "$message_count" -lt "$MIN_SESSION_LENGTH" ]]; then
        log_status "Short session ($message_count messages), skipping detailed analysis"
        exit 0
    fi

    log_status "Session had $message_count user messages"

    # Check for session observation directory
    local session_obs_dir=""
    if [[ -f "$LEARNING_DIR/.current-session-dir" ]]; then
        session_obs_dir=$(cat "$LEARNING_DIR/.current-session-dir")
    fi

    # Analyze corrections if available
    local correction_count=0
    if [[ -n "$session_obs_dir" && -d "$session_obs_dir" ]]; then
        correction_count=$(analyze_corrections "$session_obs_dir")

        if [[ "$correction_count" -gt 0 ]]; then
            log_status "Found $correction_count corrections to analyze"
            queue_for_analysis "$session_obs_dir" "$session_id"
        fi
    fi

    # Create session summary
    local session_file
    session_file=$(create_session_summary "$session_id" "$message_count" "$correction_count")

    # Capture feature state
    capture_feature_state

    # Check if we should block and request documentation
    # Only block for substantial sessions with corrections
    if [[ "$message_count" -ge 5 && "$correction_count" -gt 0 ]]; then
        # Output JSON to block and request documentation
        cat << EOF
{
  "decision": "block",
  "reason": "Before ending, please update the session file at $session_file with a summary of this session. Document what was accomplished, any issues encountered, and notes for the next session. Also, review the $correction_count correction(s) detected and consider if any should become permanent learnings."
}
EOF
    else
        log_status "Session evaluation complete"
        # Clean up current session markers
        rm -f "$LEARNING_DIR/.current-session-id" 2>/dev/null || true
        rm -f "$LEARNING_DIR/.current-session-dir" 2>/dev/null || true
    fi
}

main "$@"
