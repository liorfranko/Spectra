---
description: Create an implementation plan (plan.md) from the specification document
---

# /projspec.plan Command

This command guides the creation of an implementation plan (plan.md) based on the specification document (spec.md). It transforms a structured specification into an actionable implementation roadmap.

## Prerequisites

- A spec must exist and be in the "spec" phase
- The spec.md file should be populated with the feature specification
- User should be in the spec's worktree or the main repository

## Execution Steps

Follow these steps exactly to create the implementation plan:

### Step 1: Detect Current Spec

Find the active spec by listing the `.projspec/specs/active/` directory:

```bash
ls .projspec/specs/active/
```

If the directory is empty or doesn't exist, output this error and stop:

```
Error: No active specs found.

Create a new spec first with: /projspec.new <spec-name>
```

If multiple specs are found, list them and ask the user which one to use:

```
Multiple active specs found:
- {SPEC_ID_1}: {SPEC_NAME_1} (phase: {PHASE_1})
- {SPEC_ID_2}: {SPEC_NAME_2} (phase: {PHASE_2})

Which spec would you like to create a plan for? Please provide the spec ID.
```

### Step 2: Load State Configuration

Read the state.yaml file for the selected spec:

```bash
cat .projspec/specs/active/{SPEC_ID}/state.yaml
```

Parse the YAML to extract:
- `SPEC_ID`: The spec identifier
- `SPEC_NAME`: The spec name
- `PHASE`: Current phase
- `WORKTREE_PATH`: Path to the worktree

### Step 3: Validate Phase is "spec"

Check that the current phase is "spec". Handle other phases accordingly:

**If phase is "new":**
```
This spec is still in the "new" phase.

The specification document must be created first.
Please run: /projspec.spec

Then run /projspec.plan after the spec.md is complete.
```

**If phase is "plan" or later:**
```
This spec already has an implementation plan.

Current phase: {PHASE}
Plan file: {WORKTREE_PATH}/specs/{SPEC_ID}/plan.md

Would you like to:
1. View the existing plan.md
2. Regenerate the plan.md (this will overwrite the existing file)

Please choose an option.
```

If the user chooses option 2, proceed with the remaining steps to regenerate.

### Step 4: Read spec.md

Read the specification file from the worktree:

```bash
cat {WORKTREE_PATH}/specs/{SPEC_ID}/spec.md
```

If the file doesn't exist or is empty, output this error:

```
Error: spec.md not found or empty at {WORKTREE_PATH}/specs/{SPEC_ID}/spec.md

Please create the specification first with: /projspec.spec
```

### Step 5: Analyze Specification and Identify Technical Considerations

Review the spec.md content and identify:

- Key technical decisions that need to be made
- Potential implementation approaches
- Dependencies and integration points
- Testing requirements

Ask up to 3 targeted questions if there are significant gaps in technical understanding:

**Question Format:**

```
I've reviewed the specification for "{SPEC_NAME}". Before creating the implementation plan, I have a few technical questions:

1. [Question about technical approach or architecture]
2. [Question about dependencies or tooling]
3. [Question about constraints or existing patterns to follow]

Please provide your answers, or type "skip" if you'd like me to proceed with reasonable assumptions based on the codebase.
```

Wait for user responses before proceeding. If the user provides answers, incorporate them into the plan.

### Step 6: Analyze Codebase Context

Before creating the plan, gather context from the existing codebase:

1. **Identify relevant existing files**: Look for patterns, similar implementations, or related code
2. **Understand project structure**: Review the directory layout and conventions
3. **Check for dependencies**: Note existing packages, tools, or frameworks in use

This context should inform the technical decisions in the plan.

### Step 7: Create plan.md

Create the implementation plan at `{WORKTREE_PATH}/specs/{SPEC_ID}/plan.md` with the following structure.

**Important:** Replace all placeholders with actual content derived from the spec.md and codebase analysis. Do NOT leave placeholder text.

```markdown
# {SPEC_NAME} Implementation Plan

> Auto-generated by /projspec.plan from spec.md

---

## Summary

<!-- Brief overview of what will be built and the implementation approach -->

[1-2 paragraph summary of the implementation approach based on the specification. Describe the high-level strategy for delivering the feature.]

---

## Technical Context

<!-- Language, frameworks, tools, and dependencies -->

### Language & Runtime

- **Primary Language**: [e.g., Python 3.11+]
- **Runtime**: [e.g., Standard library, async support if needed]

### Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| [package-name] | [version] | [why it's needed] |

### Development Tools

- **Build**: [e.g., hatch, setuptools, make]
- **Test**: [e.g., pytest, unittest]
- **Lint**: [e.g., ruff, black, mypy]

---

## Project Structure

<!-- File and directory layout for the implementation -->

```
{WORKTREE_PATH}/
├── [directory]/
│   ├── [file.py]           # [purpose]
│   └── [subdirectory]/
│       └── [file.py]       # [purpose]
├── tests/
│   └── [test_file.py]      # [test coverage]
└── [other relevant files]
```

### New Files to Create

| File Path | Purpose |
|-----------|---------|
| `[path/to/file.py]` | [what this file does] |

### Files to Modify

| File Path | Changes |
|-----------|---------|
| `[path/to/existing.py]` | [what changes are needed] |

---

## Component Architecture

<!-- Key components and their relationships -->

### Component Overview

```
[ASCII diagram or description of component relationships]

┌─────────────────┐     ┌─────────────────┐
│   Component A   │────▶│   Component B   │
└─────────────────┘     └─────────────────┘
        │                       │
        ▼                       ▼
┌─────────────────┐     ┌─────────────────┐
│   Component C   │     │   Component D   │
└─────────────────┘     └─────────────────┘
```

### Component Details

#### [Component Name]

- **Purpose**: [What this component does]
- **Responsibilities**:
  - [Responsibility 1]
  - [Responsibility 2]
- **Interfaces**: [How other components interact with it]

#### [Component Name]

- **Purpose**: [What this component does]
- **Responsibilities**:
  - [Responsibility 1]
  - [Responsibility 2]
- **Interfaces**: [How other components interact with it]

---

## Build Order

<!-- Implementation sequence with dependencies -->

The implementation should proceed in the following order:

### Phase 1: Foundation
*Prerequisites: None*

1. **[Task description]**
   - Files: `[path/to/file]`
   - Estimated effort: [Small/Medium/Large]

2. **[Task description]**
   - Files: `[path/to/file]`
   - Estimated effort: [Small/Medium/Large]

### Phase 2: Core Implementation
*Prerequisites: Phase 1 complete*

3. **[Task description]**
   - Files: `[path/to/file]`
   - Estimated effort: [Small/Medium/Large]

4. **[Task description]**
   - Files: `[path/to/file]`
   - Estimated effort: [Small/Medium/Large]

### Phase 3: Integration
*Prerequisites: Phase 2 complete*

5. **[Task description]**
   - Files: `[path/to/file]`
   - Estimated effort: [Small/Medium/Large]

### Phase 4: Testing & Polish
*Prerequisites: Phase 3 complete*

6. **[Task description]**
   - Files: `[path/to/file]`
   - Estimated effort: [Small/Medium/Large]

---

## Risk Assessment

<!-- Potential issues and mitigation strategies -->

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| [Potential issue] | Low/Medium/High | Low/Medium/High | [How to prevent or handle] |
| [Potential issue] | Low/Medium/High | Low/Medium/High | [How to prevent or handle] |

### Technical Risks

- **[Risk category]**: [Specific risk and mitigation approach]

### Dependencies & External Risks

- **[External dependency]**: [Risk if unavailable and fallback plan]

---

## Testing Strategy

<!-- How the implementation will be tested -->

### Unit Tests

- **Coverage Target**: [e.g., 80%+]
- **Framework**: [e.g., pytest]
- **Key Test Cases**:
  - [ ] [Test case description]
  - [ ] [Test case description]
  - [ ] [Test case description]

### Integration Tests

- [ ] [Integration scenario to test]
- [ ] [Integration scenario to test]

### Manual Testing

- [ ] [Manual test scenario]
- [ ] [Manual test scenario]

### Test Files

| Test File | Coverage |
|-----------|----------|
| `tests/[test_file.py]` | [What it tests] |

---

## Implementation Notes

<!-- Additional guidance for implementation -->

### Coding Standards

- Follow existing project conventions
- [Any specific standards to follow]

### Key Decisions

| Decision | Rationale |
|----------|-----------|
| [Technical choice made] | [Why this approach was chosen] |

### Open Items

- [ ] [Any items needing resolution during implementation]

---

**Phase Checklist**

Before moving to the tasks phase, ensure:

- [ ] Technical approach is clear and feasible
- [ ] All components are identified
- [ ] Build order accounts for dependencies
- [ ] Risks are identified with mitigations
- [ ] Testing strategy covers acceptance criteria
- [ ] No blocking open questions remain
```

### Step 8: Update state.yaml

Update the phase in state.yaml from "spec" to "plan":

Read the current state.yaml:
```bash
cat .projspec/specs/active/{SPEC_ID}/state.yaml
```

Modify the `phase` field from `spec` to `plan` and write the updated content back to the file.

The updated state.yaml should have:
```yaml
phase: plan
```

### Step 9: Output Success Message

Report success to the user:

```
Implementation plan created successfully!

  Spec ID:    {SPEC_ID}
  Name:       {SPEC_NAME}
  Phase:      spec -> plan
  Plan file:  {WORKTREE_PATH}/specs/{SPEC_ID}/plan.md

The implementation plan includes the following sections:
- Summary
- Technical Context
- Project Structure
- Component Architecture
- Build Order
- Risk Assessment
- Testing Strategy

Next steps:
  1. Review the plan.md file and refine as needed
  2. When ready, run: /projspec.tasks to generate the task list
```

## Error Handling

If any step fails:
- For missing spec.md: Guide user to create specification first with /projspec.spec
- For phase "new": Redirect to /projspec.spec command
- For state.yaml read errors: Check file permissions and path
- For file write errors: Check directory permissions

Report the specific error and suggest remediation steps.

## Example Usage

```
User: /projspec.plan

Claude:
1. Detects spec a1b2c3d4 (user-auth) in "spec" phase
2. Reads spec.md content
3. Analyzes codebase for context
4. Asks 1-2 technical questions if needed
5. User provides answers
6. Creates plan.md with implementation approach
7. Updates state.yaml phase to "plan"
8. Reports success with next steps
```

## Notes

- The plan.md content should be derived from spec.md and codebase analysis
- Consider existing code patterns and conventions when planning
- Build order should reflect actual dependencies between tasks
- Risk assessment should be realistic and include mitigations
- Testing strategy should align with acceptance criteria from spec.md
- Component architecture should match project's existing patterns where applicable
